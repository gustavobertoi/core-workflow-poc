// Package schema provides testing for schema functionality
//
//nolint:gosec // Using weak random is acceptable for test data generation
package schema

import (
	"encoding/json"
	"fmt"
	"math/rand" //nolint:gosec // Using weak random is acceptable for test data generation
	"testing"

	"github.com/go-faker/faker/v4"
)

// UserProfile represents a user profile for testing with faker
type UserProfile struct {
	Username    string      `faker:"username" json:"username"`
	Email       string      `faker:"email" json:"email"`
	Age         int         `faker:"boundary_start=18, boundary_end=90" json:"age"`
	Address     Address     `json:"address"`
	Preferences Preferences `json:"preferences"`
}

// Address represents a user address for testing
type Address struct {
	Street string `json:"street"`
	City   string `faker:"word" json:"city"`
	State  string `faker:"word" json:"state"`
	Zip    string `json:"zip"`
}

// Preferences represents user preferences for testing
type Preferences struct {
	Theme         string `json:"theme"`
	Notifications bool   `json:"notifications"`
}

// Product represents a product for testing with faker
type Product struct {
	ID          string     `json:"id"`
	Name        string     `json:"name"`
	Description string     `faker:"sentence" json:"description"`
	Price       float64    `faker:"boundary_start=0.99, boundary_end=1000" json:"price"`
	Category    string     `json:"category"`
	Inventory   Inventory  `json:"inventory"`
	Dimensions  Dimensions `json:"dimensions"`
}

// Inventory represents product inventory for testing
type Inventory struct {
	Quantity  int    `faker:"boundary_start=0, boundary_end=1000" json:"quantity"`
	SKU       string `json:"sku"`
	Warehouse string `faker:"word" json:"warehouse"`
}

// Dimensions represents product dimensions for testing
type Dimensions struct {
	Length float64 `faker:"boundary_start=0.1, boundary_end=100" json:"length"`
	Width  float64 `faker:"boundary_start=0.1, boundary_end=100" json:"width"`
	Height float64 `faker:"boundary_start=0.1, boundary_end=100" json:"height"`
	Weight float64 `faker:"boundary_start=0.1, boundary_end=50" json:"weight"`
}

// TestUserProfileSchemaWithFaker tests the user profile schema with faker-generated data
func TestUserProfileSchemaWithFaker(t *testing.T) {
	// Load the schema
	schemaFile := "../../examples/schemas/user_profile.json"
	schema, err := LoadSchemaFromFile(schemaFile)
	if err != nil {
		t.Fatalf("Failed to load schema: %v", err)
	}

	// Generate and test 5 random user profiles
	for i := 0; i < 5; i++ {
		// Generate a fake user profile
		user := UserProfile{}
		err := faker.FakeData(&user)
		if err != nil {
			t.Fatalf("Failed to generate fake data: %v", err)
		}

		// Manually set values that can't be generated by faker
		user.Preferences.Theme = generateRandomTheme()
		user.Preferences.Notifications = rand.Intn(2) == 1 // Random boolean
		user.Address.Street = fmt.Sprintf("%d %s", rand.Intn(999)+1, faker.Word())
		user.Address.Zip = fmt.Sprintf("%05d", rand.Intn(90000)+10000)

		// Convert to map for validation
		userData, err := structToMap(user)
		if err != nil {
			t.Fatalf("Failed to convert struct to map: %v", err)
		}

		// Validate against schema
		result := schema.Validate(userData)
		if !result.Valid {
			errorsJSON, _ := json.Marshal(result.Errors)
			t.Errorf("Validation failed for user profile: %s, errors: %s", user.Username, errorsJSON)
		} else {
			t.Logf("Successfully validated user profile: %s", user.Username)
		}
	}

	// Test invalid data
	invalidUser := map[string]interface{}{
		"username": "a", // Too short
		"email":    "invalid-email",
		"age":      float64(10), // Too young
	}

	result := schema.Validate(invalidUser)
	if result.Valid {
		t.Errorf("Expected invalid user data to fail validation, but it passed")
	} else {
		t.Logf("Successfully detected invalid user data")
	}
}

// TestProductSchemaWithFaker tests the product schema with faker-generated data
func TestProductSchemaWithFaker(t *testing.T) {
	// Load the schema
	schemaFile := "../../examples/schemas/product.json"
	schema, err := LoadSchemaFromFile(schemaFile)
	if err != nil {
		t.Fatalf("Failed to load schema: %v", err)
	}

	// Generate and test 5 random products
	for i := 0; i < 5; i++ {
		// Generate a fake product
		product := Product{}
		err := faker.FakeData(&product)
		if err != nil {
			t.Fatalf("Failed to generate fake data: %v", err)
		}

		// Manually set values that can't be generated by faker
		product.ID = generateProductID()
		product.Name = generateProductName()
		product.Category = generateRandomCategory()
		product.Inventory.SKU = generateProductSKU()

		// Convert to map for validation
		productData, err := structToMap(product)
		if err != nil {
			t.Fatalf("Failed to convert struct to map: %v", err)
		}

		// Validate against schema
		result := schema.Validate(productData)
		if !result.Valid {
			errorsJSON, _ := json.Marshal(result.Errors)
			t.Errorf("Validation failed for product: %s, errors: %s", product.ID, errorsJSON)
		} else {
			t.Logf("Successfully validated product: %s", product.ID)
		}
	}

	// Test invalid data
	invalidProduct := map[string]interface{}{
		"id":    "INVALID-ID", // Wrong format
		"name":  "A",          // Too short
		"price": float64(-10), // Negative price
	}

	result := schema.Validate(invalidProduct)
	if result.Valid {
		t.Errorf("Expected invalid product data to fail validation, but it passed")
	} else {
		t.Logf("Successfully detected invalid product data")
	}
}

// Helper function to convert a struct to a map
func structToMap(obj interface{}) (map[string]interface{}, error) {
	data, err := json.Marshal(obj)
	if err != nil {
		return nil, err
	}

	var result map[string]interface{}
	if err := json.Unmarshal(data, &result); err != nil {
		return nil, err
	}

	return result, nil
}

// Helper function to generate a random theme
func generateRandomTheme() string {
	themes := []string{"light", "dark", "system"}
	return themes[rand.Intn(len(themes))]
}

// Helper function to generate a random category
func generateRandomCategory() string {
	categories := []string{"electronics", "clothing", "books", "home", "beauty", "sports", "food", "other"}
	return categories[rand.Intn(len(categories))]
}

// Helper function to generate a product ID
func generateProductID() string {
	return fmt.Sprintf("PROD-%06d", rand.Intn(900000)+100000)
}

// Helper function to generate a product name
func generateProductName() string {
	adjectives := []string{"Premium", "Deluxe", "Advanced", "Smart", "Professional", "Ultra", "Compact"}
	nouns := []string{"Widget", "Device", "Gadget", "Tool", "System", "Product", "Solution"}

	return fmt.Sprintf("%s %s", adjectives[rand.Intn(len(adjectives))], nouns[rand.Intn(len(nouns))])
}

// Helper function to generate a product SKU
func generateProductSKU() string {
	chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	sku := "SKU-"
	for i := 0; i < 8; i++ {
		sku += string(chars[rand.Intn(len(chars))])
	}
	return sku
}
